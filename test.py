from network import Net,Net0
import numpy as np
import torch
import torch.nn.functional as F
import torch.nn as nn
# import matplotlib.pyplot as plt
from PIL import Image
import random
import os
import getdata
# from sklearn.metrics import roc_auc_score
from getdata import DogsVSCatsDataset as DVCD
from torch.utils.data import DataLoader as DataLoader
from indicator import Indicator_V2

dataset_dir = './pics_fold'  # 数据集路径
model_file = './model/model4.pth'  # 模型保存路径
# N = 664
N = 50

# def test(dataset_dir, model_file):
#     # setting model
#     model = Net()  # 实例化一个网络
#     # model.cuda()                                        # 送入GPU，利用GPU计算
#     model = nn.DataParallel(model)
#     model.load_state_dict(torch.load(model_file))  # 加载训练好的模型参数
#     model.eval()  # 设定为评估模式，即计算过程中不要dropout
#
#     # get data
#     files = random.sample(os.listdir(dataset_dir), N)  # 随机获取N个测试图像
#     imgs = []  # img
#     imgs_data = []  # img data
#     labels = []
#     for file in files:
#         img = Image.open(dataset_dir + file)  # 打开图像
#         img_data = getdata.dataTransform(img)  # 转换成torch tensor数据
#
#         imgs.append(img)  # 图像list
#         imgs_data.append(img_data)  # tensor list
#
#         name = file.split(sep='.')
#         if name[0] == 'Leg':
#             labels.append(0)
#         else:
#             labels.append(1)
#     imgs_data = torch.stack(imgs_data)  # tensor list合成一个4D tensor
#
#     # calculation
#     out = model(imgs_data)  # 对每个图像进行网络计算
#     out = F.softmax(out, dim=1)  # 输出概率化
#     out = out.data.cpu().numpy()  # 转成numpy数据
#
#     # print results         显示结果
#     # print(files)
#     # print(labels)
#     acc = 0
#     TP = 0  # 把正样本成功预测为正
#     TN = 0  # 把负样本成功预测为负
#     FP = 0  # 把负样本错误地预测为正
#     FN = 0  # 把正样本错误的预测为负
#     y_true = []
#     y_scores = []
#     for idx in range(N):
#         # plt.figure()
#         if out[idx, 0] > out[idx, 1]:
#             if labels[idx] == 0:
#                 acc += 1
#                 TP += 1
#                 y_true.append(1)
#                 y_scores.append(out[idx, 0])
#                 # plt.suptitle('img:{},Leg:{:.1%},Mal:{:.1%}'.format(files[idx], out[idx, 0], out[idx, 1]))
#             else:
#                 print(str(files[idx]) + ' is wrong')
#                 FN += 1
#                 y_true.append(0)
#                 y_scores.append(out[idx, 1])
#                 # plt.suptitle('img:{},Leg:{:.1%},Mal:{:.1%}'.format(files[idx], out[idx, 0], out[idx, 1]))
#         else:
#             if labels[idx] == 1:
#                 acc += 1
#                 TN += 1
#                 y_true.append(0)
#                 y_scores.append(out[idx, 1])
#                 # plt.suptitle('img:{},Mal:{:.1%},Leg:{:.1%}'.format(files[idx], out[idx, 1], out[idx, 0]))
#             else:
#                 print(str(files[idx]) + ' is wrong')
#                 FP += 1
#                 y_true.append(1)
#                 y_scores.append(out[idx, 0])
#                 # plt.suptitle('img:{},Leg:{:.1%},Mal:{:.1%}'.format(files[idx], out[idx, 0], out[idx, 1]))
#         # plt.imshow(imgs[idx])
#     # plt.show()
#     ACC = acc / N
#     precision = TP / (TP + FP)
#     recall = TP / (TP + FN)
#     F1_score = (2 * precision * recall) / (precision + recall)
#     MCC = (TP * TN - FP * FN) / pow((TP + FP) * (TP + FN) * (TN + FP) * (TN + FN), 0.5)
#     AUC = roc_auc_score(y_true, y_scores)
#     print('acc: ' + str(ACC))
#     print('precision:  ' + str(precision))
#     print('recall:  ' + str(recall))
#     print('F1-score:  ' + str(F1_score))
#     print('MCC:  ' + str(MCC))
#     print('auc:  ')
#     print(AUC)
#
#     return ACC, precision, recall, F1_score, MCC
batch_size = 16
workers = 4
def test(dataset_dir, model_file, model_type):
    # setting model
    model = model_type().cuda()  # 实例化一个网络
    # model.cuda()                                        # 送入GPU，利用GPU计算
    model = nn.DataParallel(model)
    model.load_state_dict(torch.load(model_file))  # 加载训练好的模型参数
    model.eval()  # 设定为评估模式，即计算过程中不要dropout

    datafile = DVCD('test', dataset_dir)  # 实例化一个数据集
    dataloader = DataLoader(datafile, batch_size=batch_size, shuffle=False, num_workers=workers,
                            drop_last=False)
    print('Dataset loaded! length of test set is {0}'.format(len(datafile)))
    all_label = []
    all_out = []
    for img, label in dataloader:  # 循环读取封装后的数据集，其实就是调用了数据集中的__getitem__()方法，只是返回数据格式进行了一次封装
        # img, label = Variable(img), Variable(label)  # 将数据放置在PyTorch的Variable节点中，并送入GPU中作为网络计算起点
        img = img.cuda()
        label = label.cuda()
        out = F.softmax(model(img), dim=-1)  # 计算网络输出值，就是输入网络一个图像数据，输出猫和狗的概率，调用了网络中的forward()方法
        # out = model(img)
        all_label.append(label.cpu().numpy())
        all_out.append(out.detach().cpu().numpy())
    labels = np.concatenate(all_label, axis=0)
    out = np.concatenate(all_out, axis=0)

    ind = Indicator_V2(out.argmax(axis=-1).reshape(-1),labels.reshape(-1))
    indicator_name = ['acc','precision','recall','fmeature',
                      'specific','tpr','fpr','mcc','auc']
    result = []
    for name in indicator_name:
        result.append(eval('ind.get_{}()'.format(name)))
    print(result)
    return result
# if __name__ == '__main__':
    # test(dataset_dir, model_file)
    # from torchsummary import summary
    # model = Net().cuda()
    # summary(model, input_size=[(3,200,200)], batch_size=3, device='cuda')
